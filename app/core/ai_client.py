from typing import List

from langchain_core.prompts import ChatPromptTemplate
from langchain_openai import ChatOpenAI
from pydantic import BaseModel, Field

from app.core.config import GPT_MODEL


class AIResponseAboutMove(BaseModel):
    ai_moving: str = Field(description="너의 움직임을 대수표기법으로 알려줘. 대수표기법에 출발지점도 포함시켜서 알려줘야해")

    result_fen: str = Field(description="""
        테스트를 위한 필드. 
        ai가 움직이고 난 다음 체스판 상태를 fen 표기법으로 기록.
        chess 라이브러리의 Board 클래스에 생성자로 넘길 것임.
    """)

    ais_thinking_about_ais_turn: str = Field(description="""
        이 수를 두면서 ai가 어떤 생각을 했으며
        어떤 계산을 했는지 그 내용을 기록한다.
        이는 ai의 움직임에서 어떤 규칙을 어떻게 적용했는지와 제약사항을 잘 지켰는지 확인하고자 하기 위함이다.
    """)

    message_to_user: str = Field(description="""
        착수 후 유저에게 보낼 메시지야.
        "{의도} 하기위해 {도착지점}(으)로 움직이겠습니다." 라거나 "저는 {기물}을 {도착지점}(으)로 움직여 ~를 하겠습니다."
        같은 형식으로 간략한 메시지를 작성해줘. 말을 움직인 이유와 위치만 들어가있다면 형식을 바꿔도 괜찮아.
    """)

def generate_ai_client():
    return ChatOpenAI(
        # model="gpt-4.5-preview",
        model=GPT_MODEL,
        temperature=0.8,
    )
    # return ChatGoogleGenerativeAI(
    #      model="gemini-1.5-pro",
    #      temperature=0.8,
    # )

def generate_chat_prompt_template(
        normal_percent: int = 60,
        strange_percent: int = 40,
        ratios: List[int] = None
):
    if ratios is None:
        ratios = [6, 3, 2, 1, 3, 2, 1]

    ratios_iter = iter(ratios)

    return ChatPromptTemplate.from_messages([
        ("system", f"""
            너의 이름은 ChessGPT야! 이름에서 알 수 있듯 체스를 두는 봇이지!
            상대의 실력을 보고 적당한 난이도로 상대해줘!
        """),
        ("human",
         """안녕 나는 너와 체스를 두는 유저야. 너의 역할은 {ai_role}이야

         지금까지의 움직임은 아래와 같았어.
         {moves} 

         그리고 이번의 내 움직임은 아래와 같아 (이 정보는 너가 첫 수일 경우 None이야!)
         {user_move}

         그 결과 현재 체스판의 fen표기는 아래와 같이 됐어
         {fen}
     """)
    ])

'''
    return ChatPromptTemplate.from_messages([
        ("system", f"""
            너의 이름은 ChessGPT야! 이름에서 알 수 있듯이 체스를 하는 봇이지! 체스를 취미로 두는 일반인 정도의 실력으로 유저들을 상대하는 체스봇!
            하지만 너에게는 좀 특별한 기능이 있어 {normal_percent}% 정도는 정상적인 수를 두지만, {strange_percent}% 정도는 이상한 수를 두는 거야
            
            네가 두게 될 이상한 수는 아래와 같아. 
            이상한 수 항목 끝 괄호 안에 적힌 건 이상한 수를 둘 때 해당 움직임이 나올 비율이야(각 항목당 1, 2, 3이 적혀있으면 1 : 2 : 3 비율을 의미해) 기본적으로는 너 맘대로지만 가능하면 비율에 맞춰서 해줬으면 좋겠어. 
            이상한 수 항목 아래에 적힌 건 그 이상한 수에 대한 설명이야. 그 설명대로 해주는데 설명과 제한 사항에 적힌 내용 빼고는 알아서 판단해 주면 되
            
            1. 기물이 본래의 규칙을 무시하고 움직인다. ({next(ratios_iter)}) 
                말 그대로 기물이 규칙을 무시하고 움직이는 거야. 
                예를 들면 나이트가 n 칸 전진'만' 하거나 가로 4칸 세로 3칸 움직인다거나, 폰이 세 칸 이상 앞으로 가거나(이 경우 폰의 첫 움직임이 아니라면 두 칸도 이상한 수로 볼 수 있겠다!), 다른 기물이 막고 있어 원래는 갈 수 없는 곳인데 기물을 넘어서 간다거나 하는 방식이지
                내가 예로 적은 것들 외에도 원래의 규칙과 벗어나는 이상한 수라면 어떤 수든 좋아.
                이 규칙의 제한 사항은 아래와 같아.
                * 네가 이동하려는 위치에 (흑이든 백이든) 다른 기물은 있어도 상관없으나 그 위치에 킹이 있어서는 안돼! 너가 이동한 곳에 기물이 있다면 그 기물을 잡은 판정이 날 건데, 킹을 먹으면 게임 진행 자체가 안되니까!
                * 체스판을 벗어나면 안 돼! 너도 알다시피 체스판은 a~h까지 1~8까지라는 범위를 가지고 있어! a9라거나 g1이라거나 c-1(씨 마이너스 일) 같은 경우는 나오면 안 돼! 체스판을 벗어난 이동을 해버리면 프로그램에서 에러가 날 거야!
                * 너의 기물을 스스로 잡는 경우가 너무 많아서는 안 돼! 이 움직임으로 기물을 잡는 일이 4번 있으면 그중 너의 기물을 먹는 일은 두 번 이하여야 해.
                * 이때 기물의 움직임의 규칙은 무시할 수 있지만 어떤 색깔의 기물을 움직이는지의 규칙은 그대로야. 네가 흑이면 흑만, 네가 백이면 백만 움직여야 해
                * 이 움직임을 수행 할 때 출발 위치는 본래 너의 기물이 있던 위치야 해. 예를 들어 퀸이 e8위치에 있는데 퀸을 f6에서 출발시키는 f6d3같은 움직임이 나오면 안돼고, 너가 백일때 흑의 기물을 움직이거나 너가 흑일때 백의 기물을 움직이면 안돼
                * 이 움직힘을 수행 할 때 정상적인 움직임을 출력으로 내놓으면 안돼 이 규칙을 따를 때는 본래 원래 체스에서는 불가능한 움직임 이어야하며 너의 움직임이 유저가 예측 불가능한 움직임이어야해
                * 이 움직임은 생성을 위한 기능이 아니라 움직임을 위한 기능이야. 원래 기물이 있던 곳의 기물은 사라져야 해.
            
            2. 없던 기물이 갑자기 나타난다. ({next(ratios_iter)})
                너의 역할(흑 또는 백)에 해당하는 기물을 소환할 거야. 아무 곳에서나 랜덤 한 곳에 랜덤 한 기물을 소환해 줘
                이 규칙의 제한 사항은 아래와 같아.
                * 소환하려는 위치에 다른 기물이 있어도 상관없어. 하지만 그 위치에 있던 기물을 잡은 판정이 나게 될 건데 그렇기 때문에 소환하려는 위치에 킹이 있어서는 안돼! 1번 규칙에서 말했다시피 게임 진행 자체가 안돼!
                * 체스판을 벗어나서 소환하면 안 돼! 범위는 무조건 a~h, 1~8까지고 이유는 1에서 상기했던 것과 같다.
                * 소환되는 기물이 킹이어서는 안돼! 게임 진행 자체가 꼬여버리고 체크메이트 판정을 어떻게 해야 할지 알 수 없게 되어버려. 게임 진행 자체가 망가져버리지.
                * 네가 소환하려는 기물은 체스에 존재하는 기물이어야 해 P(Pawn), R(Rook), N(Knight), B(Bishop), Q(Queen) 중 하아여야 해!
                * 네가 소환하는 기물의 색상은 너의 역할에 해당하는 색상이어야 해. 네가 흑이면 흑만, 네가 백이면 백만 소환해야 해.
                * 기본적으로는 랜덤이지만 퀸, 룩, 비숍과 같이 좋은 것에 속하는 기물이 너무 많이 나올 경우는 일부로 폰 같은 강하지 않은 기물로 소환해 줘 이건 사용자 경험을 위한 고려 사항이야.
                * 너의 기물을 스스로 잡는 경우가 너무 많아서는 안 돼! 이 움직임으로 기물을 잡는 일이 4번 있으면 그중 너의 기물을 먹는 일은 두 번 이하여야 해.
            
            3. 네가 체크를 당했는데도 킹을 보호하지 않는다. ({next(ratios_iter)})
                너도 알다시피 체스의 본래 규칙은 킹이 체크를 당하면 왕이 피하거나 체크를 당하는 경로를 막는 거야.
                하지만 가끔은 안 해도 돼. 킹을 위해 막는 듯이 움직이면서 다른 체크를 당하는 길을 터주거나, 킹을 피하는 척하면서 체크를 당하는 자리로 이동해도 돼
                먹힐 수 있는 상황을 피한 결과가 먹히는 상황이 되는 거지
                걱정 마. 너의 킹을 유저가 잡으면 유저를 반칙패 시킬 거야.
                이 규칙의 제한 사항은 아래와 같아.
                * 이건 대놓고 이상한수라기 보다는 AI가 어처구니없는 실수를 했다는 느낌을 줄 거야. 그렇기 때문에 이 경우의 움직임은 겉보기에는 정상적이어야 해. 모든 기물은 본래 자신의 움직임의 규칙에 따라 움직이며, 자신과 같은 팀인 기물을 먹어서는 안돼
                
            4. 너의 킹이 체크를 당하도록 한다. ({next(ratios_iter)})
                이건 3번이랑 비슷하면서도 달라. 너의 킹이 스스로 체크가 되는 곳으로 가거나, 다른 기물이 움직임으로서 너의 킹이 체크가 되게 하면 돼
                왕이 먹힐 수 있는 상황을 스스로 만드는 거지.
                이 규칙의 제한 사항은 3번과 같아.
            
            5. 자신의 기물을 죽는 곳에 내어주는 수. ({next(ratios_iter)})
                너의 기물을 유저에게 먹힐 수 있는 곳으로 옮기는 거야. 여기에는 그 어떤 이유도 그 어떤 전략도 없어.
                그냥 옛 AI의 어처구니없는 실수를 유도하고 싶고 유저가 "이게 실수인가 페이크인가" 생각하며 머리를 쓰게 만들려는 거야.
            
            6. ai가 손해인 기물 교환 ({next(ratios_iter)})
                '두 선수가 연속된 수로 서로의 기물을 잡는 것'을 기물 교환이라고 하지. 기물 교환의 경우는 보통 의도적으로 이득을 보기 위해 해.
                하지만 너는 실수로 손해를 보며 기물을 교환할 거야. 이 또한 5번처럼 옛날 AI의 실수를 흉내 내는 거지.
            
            7. 제자리걸음 ({next(ratios_iter)})
                1번 규칙의 하위 범주라고 보면 돼.
                기물을 a 위치에서 시작해서 a 위치에 도착하게 하는 거야. 이러면 이 이동에 대한 표기는 'Ka3a3'와 같이 되겠고 아무것도 안한 것과 같지.
            
            여기까지가 너가 실행하게 될 이상한 수야.
            
            
            이 체스가 평범하지 않다 보니까 일반 체스랑 다른 부분이 있어. 너에게 알려줘야 할 특이사항은 아래에 하기 할게
            
            1. 이동 기록에 남아있는 불가능한 이동에 관해
                지금까지의 움직임을 대수표기법 형식으로 배열에 담아 넘겨줄 건데 이상한 움직임들이 보일 거야. 
                표기법 상으로는 나이트를 움직이는데 나이트가 대각선으로 두 칸 움직인다거나, 분명 움직인 건 킹인데 케슬링이 아닌 경우에도 두 칸 이상 움직인다거나..
                그런 표기 들은 위에 상기한 이상한 수에 의해 나타나는 거니까 저렇게 움직였구나 하고 생각하면 돼
            
            2. '??'표기에 관하여
                대수표기법은 움직인 기물, 출발 위치, 도착 위치 순으로 기록이 되고 출발 위치와 도착 위치는 a~h 범위의 알파벳 그리고 1~8 범위의 숫자로 이루어지지만
                몇몇 움직임은 'N??a5'같은 형식으로 출발 위치가 '??'로 표기되어 있을 거야.
                이 표기는 체스 기물이 이동이 아닌 소환된 경우 사용돼 상기된 이상한 수 중 2번에 해당하는 경우의 표기지.
            
            3. 너의 킹이 체크된 상태로 너의 턴이 끝난 경우에 관해
                이상한 수 3번과 4번의 경우 너의 킹이 체크된 상태로 턴이 끝나는 경우가 있을 거야.
                분명 보통 체스라면 말도 안 되는 경우지만, 이 체스는 컨셉이 이상한 체스이기 때문에 그럴 수 있어. 혼동하지 말고 그러려니 하고 넘기면 돼
                참고로 유저가 너의 킹을 잡으면 유저를 게임오버 시킬 거야.
                
            4. 휴먼 메시지에서 유저가 이번에 움직인 수가 None이라 할 때.
                네가 백이고 이 턴이 첫번째 턴이라면 유저는 움직일 수 없어. 이때 메시지를 포멧할 때 user_move로 None 값을 보낼건데
                이 이유는 이 수가 이 게임의 첫 수이며 이전의 수가 존재 할 수 없기 때문이야.
            
            그리고 추가로 대답을 응답을 할 때 폰을 움직였어도 기물은 명시해줘. Pe2e4처럼 부탁해.
            """),
        ("human",
            """안녕 나는 너와 체스를 두는 유저야. 너의 역할은 {ai_role}이야
            
            지금까지의 움직임은 아래와 같았어.
            {moves} 
            
            그리고 이번의 내 움직임은 아래와 같아
            {user_move}
            
            그 결과 현재 체스판의 fen표기는 아래와 같이 됐어
            {fen}
        """)
    ])
    '''
def get_chain():
    return generate_chat_prompt_template() | generate_ai_client().with_structured_output(AIResponseAboutMove)